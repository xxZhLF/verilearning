基于 Booth 的 32-Bit 乘法器。

逻辑区分：

首先，对于乘法运算：$`A \times B`$，其中$`A`$为被乘数，$`B`$为乘数。 \
将其转换为加法运算：计算$`B`$个$`A`$相加的结果。 因此， \
对$`B`$进行适当的编码，减少其二进制编码中 $`1`$ 的个数， \
便可减少$`A`$的累加次数，加速乘法计算（Booth算法）。

### Booth算法的核心思想：

将二进制数中若干个连续的 $`1`$ 转换为两个二进制数的差， \
从而减少二进制 $`1`$ 的个数，进而减少被乘数的操作次数（加或减）。

例如：$`1111_{2} = 10000_{2} - 1_{2}`$

### Booth编码： 

当$`B = 47_{10} = 00101111_{2}`$时，

$$
\begin{array}{ccccccccc|r}
     0 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & \overset{\ast}{0} &    \\
\hline
       &   &   &   &   &   &   & 1 &                0  & -1 \\
       &   &   &   &   &   & 1 & 1 &                   &  0 \\
       &   &   &   &   & 1 & 1 &   &                   &  0 \\
       &   &   &   & 1 & 1 &   &   &                   &  0 \\
       &   &   & 0 & 1 &   &   &   &                   &  1 \\
       &   & 1 & 0 &   &   &   &   &                   & -1 \\
       & 0 & 1 &   &   &   &   &   &                   &  1 \\
     0 & 0 &   &   &   &   &   &   &                   &  0 \\
\end{array}
$$

$`\ast`$标记的 $`0`$ 为手动添加，作用参考核心思想的例如。\
*（从最低位开始按位求补）*

Booth编码为：$`\overset{2^{7}} {0},  \
              \overset{2^{6}}{ 1},  \
              \overset{2^{5}}{-1},  \
              \overset{2^{4}}{ 1},  \
              \overset{2^{3}}{ 0},  \
              \overset{2^{2}}{ 0},  \
              \overset{2^{1}}{ 0},  \
              \overset{2^{0}}{-1}`$ \
验证：$`2^{7} - 2^{6} + 2^{5} - 2^{0} = 64 - 32 + 16 - 1 = 47_{10}`$

$`n`$位二进制数$`B`$的原码$`B_{2,T}`$与其补码$`B_{2,C}`$存在：
$`2^{n+1} = B_{T} + B_{C}`$。 \
通用表达式：

$$\begin{aligned}
     B_{10} &= - b_{n-1} \cdot 2^{n-1} 
               + b_{n-2} \cdot 2^{n-2} 
               + b_{n-3} \cdot 2^{n-3} 
               + \cdots
               + b_{  2} \cdot 2^{  2}  
               + b_{  1} \cdot 2^{  1}  
               + b_{  0} \cdot 2^{  0}  
               + b_{ -1}, \quad b_{-1} = 0 \qquad (\textup{I})
\end{aligned}$$

关于最高位为什么带负号：因为$`b_{n \sim 0}`$为$`B_{10}`$的补码，最高位为符号位。 \
例如：当$`B_{10} \!= -3`$时， \
$`\qquad\qquad
  B_{2} ~= 1111_{T} = 1001_{C} = -2^{3} + 2^{0} = -8_{10} + 1_{10} = -3_{10}`$

对通用表达式$`(\textup{I})`$进行变形，得到表达式$`(\textup{II})`$。

$$\begin{aligned}
     B_{10} &=    - b_{n-1} \cdot 2^{n-1} \\
            &~~~~ + b_{n-2} \cdot 2^{n-2} + (b_{n-2} \cdot 2^{n-2} - b_{n-2} \cdot 2^{n-2}) \\
            &~~~~ + b_{n-3} \cdot 2^{n-3} + (b_{n-3} \cdot 2^{n-3} - b_{n-3} \cdot 2^{n-3}) \\
            &~~~~ ~ ~ \vdots \\
            &~~~~ + b_{  2} \cdot 2^{  2} + (b_{  2} \cdot 2^{  2} - b_{  2} \cdot 2^{  2}) \\
            &~~~~ + b_{  1} \cdot 2^{  1} + (b_{  1} \cdot 2^{  1} - b_{  1} \cdot 2^{  1}) \\
            &~~~~ + b_{  0} \cdot 2^{  0} + (b_{  0} \cdot 2^{  0} - b_{  0} \cdot 2^{  0}) + b_{-1}
\\
            &=   (- b_{n-1} \cdot 2^{n-1} + 2 \times b_{n-2} \cdot 2^{n-2})
               + (- b_{n-2} \cdot 2^{n-2} + 2 \times b_{n-3} \cdot 2^{n-3})
               + \\ 
            &~~~~ \cdots 
               + (- b_{  2} \cdot 2^{  2} + 2 \times b_{  1} \cdot 2^{  1})
               + (- b_{  1} \cdot 2^{  1} + 2 \times b_{  0} \cdot 2^{  0})
               + (- b_{  0} \cdot 2^{  0} +          b_{ -1}) 
\\
            &=   2^{n-1}(- b_{n-1} + b_{n-2})
               + 2^{n-2}(- b_{n-2} + b_{n-3})
               + \cdots
               + 2^{  2}(- b_{  2} + b_{  1})
               + 2^{  1}(- b_{  1} + b_{  0})
               +        (- b_{  0} + b_{ -1}) \qquad (\textup{II})
\end{aligned}$$

由表达式$`(\textup{II})`$可以看出，从低位到高位扫描，
连续的 $`0`$ 或 $`1`$ 均被编码为 $`0`$， \
$`0 \leftarrow 1`$ 编码为 $`+1`$，
$`1 \leftarrow 0`$ 编码为 $`-1`$。综上所述，Booth算法如下：

### Booth算法（Radix-2）： 

| $`b_{i}`$ | $`b_{i-1}`$ | W | 操作$`\qquad\quad`$ |
|:-:|:-:|--:|--:|
| 0 | 0 |  0 | $`A << 1`$ |
| 0 | 1 | +1 | $`PP_{i} += A << 1`$ |
| 1 | 0 | -1 | $`PP_{i} -= A << 1`$ |
| 1 | 1 |  0 | $`A << 1`$ |

此时，基于Booth算法进行乘法运算，需要从低到高扫描所有二进制位， \
依据相邻两位值的变化执行不同的操作。对于$`n`$位二进制数$`B`$来说，任然 \
需要$`n`$个时钟周期才能给出运算结果。

与软件代码不同，对于硬件电路，对每一位二进制数进行检查之后， \
无论是否进行复杂的运算，所需要的时钟周期数是相同的。因此，当前的Booth算法 \
并不能提高运算的执行效率。不过，Booth算法任然具有很大的优化空间。具体如下：

### Booth算法・改（Radix-4）： 

对通用表达式$`(\textup{I})`$进行变形，得到表达式$`(\textup{III})`$。

$$
\begin{aligned}
     B_{10} &= -2
\end{aligned}
$$