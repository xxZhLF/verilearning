基于减法器构成的 32-Bbf 除法器。

逻辑区分：时序逻辑

例，二进制除法：$`7 \div 4 = 1 \cdots 3`$

                0 1    
           ---------   
    1 0 0 / 0 1 1 1    
            0 0 0      
            ------     
              1 1 1    
              1 0 0    
             -------   
                1 1    

以上是手动计算除法的过程。存在两个问题： \
对于32为二进制的除法运算，如何快速判断除数最低有效位数？ \
知道除数的最低有效位数后，如何动态分割被除数与除数等长？

因此，这里采用一种， \
虽然有运算效率不高， \
但硬件实现相对简单，的计算过程：

当 $`7_{10} = 00000111_{2}`$ \
$`4_{10} = 00000100_{2}`$ 时 \
有：

    Dived:                 | 0 0 0 0 0 1 1 1 
    Divor: 0 0 0 0 0 1 0 0 |                  
    
    Remai: 0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 1) ? (Dived >> 1) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 2) ? (Dived >> 2) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 3) ? (Dived >> 3) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 4) ? (Dived >> 4) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 5) ? (Dived >> 5) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 6) ? (Dived >> 6) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 = Remai > (Dived >> 7) ? (Dived >> 7) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 
         - 0 0 0 0 0 0 0 0 | 0 0 0 0 0 1 0 0 = Remai > (Dived >> 8) ? (Dived >> 8) : 0 
    ----------------------------------------
           0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 1 1  

从上面例子中可以总结出除法的执行步骤：
1. 被除数与除数长度扩展为$`2`$倍
   - 被除数高位补$`0`$，除数低位补$`0`$
2. 被除数写入余数寄存器
3. 除数写入除数寄存器
4. 之后的步骤重复$`n`$次（$`n`$位二进制位数）
   1. 除数右移$`1`$位
   2. 判断除数与余数的大小关系
      - 除数 $`>`$ 余数
        - 商记为$`0`$
        - 余数不变
      - 除数 $`<=`$ 余数
        - 商记为$`1`$
        - 更新余数寄存器（余数 $`-`$ 除数）

除法器很难像乘法器那样用族和逻辑实现， \
因为运算过程依赖所有余数的中间结果，组合逻辑将变得十分复杂。