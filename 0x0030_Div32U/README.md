基于减法器构成的 32-Bbf 除法器。

逻辑区分：时序逻辑

例，二进制除法：$`7 \div 4 = 1 \cdots 3`$

                0 1    
           ---------   
    1 0 0 / 0 1 1 1    
            0 0 0      
            ------     
              1 1 1    
              1 0 0    
             -------   
                1 1    

以上是手动计算除法的过程。存在两个问题： \
对于32为二进制的除法运算，如何快速判断除数最低有效位数？ \
知道除数的最低有效位数后，如何动态分割被除数与除数等长？

因此，这里采用一种， \
虽然有运算效率不高， \
但硬件实现相对简单，的计算过程：

当 $`7_{10} = 00000111_{2}`$ \
$`4_{10} = 00000100_{2}`$ 时 \
有：

```math
\begin{array}{ccccccccccccccccc}
    Dived & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
    Divor & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} & \bf{0} \\ 
    \\
    Remai & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
        - & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
          & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\ 
\end{array}
\begin{array}{ccccc}
    \\  % Dived
    \\  % Divor
    \\  % 
    \\
    = & Divor & >> & 1  & \times & 0 \leftarrow (0000,0010,0000,0000 > Remai) \\
    \\
    = & Divor & >> & 2  & \times & 0 \leftarrow (0000,0001,0000,0000 > Remai) \\
    \\
    = & Divor & >> & 3  & \times & 0 \leftarrow (0000,0000,1000,0000 > Remai) \\
    \\
    = & Divor & >> & 4  & \times & 0 \leftarrow (0000,0000,0100,0000 > Remai) \\
    \\
    = & Divor & >> & 5  & \times & 0 \leftarrow (0000,0000,0010,0000 > Remai) \\
    \\
    = & Divor & >> & 6  & \times & 0 \leftarrow (0000,0000,0001,0000 > Remai) \\
    \\
    = & Divor & >> & 7  & \times & 0 \leftarrow (0000,0000,0000,1000 > Remai) \\
    \\
    = & Divor & >> & 8  & \times & 1 \leftarrow (0000,0000,0000,0100 < Remai) \\
    \\
\end{array}
```

从上面例子中可以总结出除法的执行步骤：
1. 被除数与除数长度扩展为$`2`$倍
   - 被除数高位补$`0`$，除数低位补$`0`$
2. 被除数写入余数寄存器
3. 之后的步骤重复$`n`$次（$`n`$位二进制位数）
   1. 除数右移$`1`$位
   2. 判断除数与余数的大小关系
      - 除数 $`>`$ 余数
        - 商记为$`0`$
        - 余数不变
      - 除数 $`<=`$ 余数
        - 商记为$`1`$
        - 更新余数寄存器（余数 $`-`$ 除数）